<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring4 学习]]></title>
    <url>%2F2018%2F05%2F10%2F2018-05-10%20Spring4%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[xml配置配置bean 通过bean全类型反射，在IOC容器中创建bean，所以bean中必须有无参构造器，id唯一 ApplicationContext 是个IOC容器，是一个接口 BeanFactory是基本IOC容器实现，接口 新增refresh() 和close()两个方法 getBean() id 返回类型 属性注入 ： property 构造方法注入 : constructor-arg,指定参数的位置和类型区分重载的构造器 字面值包含特殊字符，用&lt;![CDATA][xxx]&gt;-引用类型用ref，字面类型用value 内部bean，外部bean自动装配 byName 根据setter风格 查找xml 中id对应相等的 byType 根据类型进行装配 bean 之间的关系 继承 parent abstract 是抽象bean 不能实例化，可以被继承 没有指定class属性的bean 是一个抽象bean 依赖 depends-onbean 作用域 scope 默认值: singleton prototype 不在容器初始化时创建bean实例，在每次请求时创建新的bean实例 singleton 容器初始化时创建，整个容器生命周期内只创建一个实例，单例的 request 用的少 session 用的少使用外部属性文件 比如dataSource 导入属性文件 &lt;context:property-placeholder location=”classpath:**.properties”&gt;SpEL #{xxx} 动态赋值 #{T(xxx) 引用类的静态属性} 引用其他bean 引用其他bean的属性 使用运算符bean的生命周期 init-method destory-method 上面两个可以自定义 初始化和销毁的方法 后置处理器 BeanPostProcessor 不需要id 自动识别 工厂模式创建bean 静态工厂方法 配置bean实例 factory-method 指向工厂方法名称 constructor-arg 指向方法的参数 实例工厂方法 配置工厂实例 通过实例工厂来配置beanFactoryBean 配置 bean 通过FactoryBean 配置Bean 实例 自定义FactoryBean 实现spring 提供的接口基于注解方式组件扫描 特定注解 @Component @Respository @Service @Controller context:component-scan 指定扫描包的范围 被管理到 会在文件左上角出现S标志 @Autowired 自动装配兼容性的单个Bean实例 自动装配的bean都需要在SpringIoc容器中 @Resource @Inject 类似泛型依赖注入]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 学习]]></title>
    <url>%2F2018%2F04%2F23%2F2017-04-23%20MongoDB%20%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[MongoDBMongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个高性能，开源，无模式的文档型数据库，是当前NoSql数据库中比较热门的一种。传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。MongoDB对于关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。MongoDB的适合对大量或者无固定格式的数据进行存储，比如：日志、缓存等。对事物支持较弱，不适用复杂的多文档（多表）的级联查询。基础教程参考博客 启动在mongoDB/bin目录下 执行两条 ./mongod # 先启动mongo服务 ./mongo # 启动mongo搭建]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud 高可用注册中心]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18-SpringCloud%20%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[高可用注册中心如上图所说的，所以我们要配置一个注册中心集群 搭建步骤 修改配置文件12345678server: port: 1111eureka: client: register-with-eureka: true # 修改为true fetch-registry: true # 修改为true，让他可以注册自己 serviceUrl: defaultZone: http://localhost:1112/eureka/ # 指向另一个注册中心 在创建一样的注册中心，只需修改配置文件，其他一样12345678server: port: 1112eureka: client: register-with-eureka: true # 修改为true fetch-registry: true # 修改为true，让他可以注册自己 serviceUrl: defaultZone: http://localhost:1111/eureka/ # 指向另一个注册中心 启动两个注册中心，首先启动的注册者会去查找备用的注册中心，因为还没有启动，会显示找不到报错。当启动第二个注册中心时，第一个会定时的去查找一遍。两个就都启动成功。无报错。分别访问http://localhost:1111/和http://localhost:1112/发现他们分别显示在对方的列表中 修改服务提供者的配置文件123456789spring: application: name: cloud-userserver: port: 3333eureka: client: serviceUrl: defaultZone: http://localhost:1111/eureka/,http://localhost:1112/eureka/ #添加两个注册中心地址 在重新启动两个注册中心，一个服务提供者，看到这个服务分别在两个注册中心都注册了。当其中一个注册中心关闭时，因为该服务也像另一个注册中心注册了，所以服务提供者依然是可用的。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Eureka(二)]]></title>
    <url>%2F2018%2F04%2F16%2F2018-04-16-SpringCloud%20Eureka(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[服务消费者在上一遍文章中，我们构建了注册中心和服务提供者，有服务，就要有消费服务的关系，这次我们搭建基于Ribbon的服务消费者。 RibbonRibbon是一个基于HTTP和TCP客户端的负载均衡器。Ribbon可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到均衡负载的作用。当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务端列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。 新建项目新建一个项目test-consumer 添加依赖pom.xml12345678910111213141516171819202122232425262728293031&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 主类中添加注解在应用主类中，通过@EnableDiscoveryClient注解来添加发现服务能力。创建RestTemplate实例，并通过@LoadBalanced注解开启均衡负载能力。123456789101112131415161718192021import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@EnableDiscoveryClient@SpringBootApplicationpublic class TestConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestConsumerApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 创建Controller层，来消费service层的服务1234567891011121314151617import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestControllerpublic class HelloController &#123; @Autowired RestTemplate restTemplate; @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String add() &#123; return restTemplate.getForEntity(&quot;http://test-service/hello&quot;, String.class).getBody(); &#125;&#125; 创建配置文件123456789spring: application: name: test-consumer #消费者的程序名称server: port: 2222 #本程序的端口eureka: client: serviceUrl: defaultZone: http://localhost:1111/eureka/ #注册中心的地址 启动程序先启动 注册中心 test-reg再启动 服务提供者 test-service在建一个服务提供者 其他都一样，改下端口配置最后启动 服务消费者 test-consumer输入http://localhost:1111/ 查看两个服务已经注册输入消费者的地址http://localhost:2222/hello输出hello这样就实现了负载均衡，Ribbon会轮询访问服务实例，关掉其中一个实例，会自动去寻找下一个。 源码我这里只建了一个服务实例。注册中心：https://github.com/FlyLesss/blogCode/tree/master/test-reg服务提供者: https://github.com/FlyLesss/blogCode/tree/master/test-service服务消费者：https://github.com/FlyLesss/blogCode/tree/master/test-consumer]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud rabbitMQ 整合Bus]]></title>
    <url>%2F2018%2F04%2F13%2F2017-04-13-SpringCloud%20rabbitMQ%20%E6%95%B4%E5%90%88%20Bus%2F</url>
    <content type="text"><![CDATA[前言当git上内容更新时，要对每个服务实例去发送Post请求，通知更新。而使用Bus(消息总线)对一个服务实例进行更新时,将刷新请求发送到消息总线上,其他在消息总线上的服务实例就会获取到，重新再config-server获取配置文件,从而实现配置信息的动态更新。请求流程 遇到的问题我建的多模块maven工程，添加version就是会报错，添加了很多个版本都有问题12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 报的错123Parameter 0 of method traceFilterRegistration in org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration required a bean of type &apos;javax.servlet.Filter&apos; that could not be found. - Bean method &apos;resourceUrlEncodingFilter&apos; in &apos;FreeMarkerServletWebConfiguration&apos; not loaded because @ConditionalOnEnabledResourceChain did not find class org.webjars.WebJarAssetLocator - Bean method &apos;remoteDevToolsDispatcherFilter&apos; not loaded because @ConditionalOnProperty (spring.devtools.remote.secret) did not find property &apos;secret&apos; 后来我把version去掉，并且放到主依赖中，自动下的事2.0.0版本,运行正常….不晓得什么原因，应该就是包冲突，坑… spring cloud 集成项目Spring Cloud Task：提供云端计划任务管理、任务调度。Spring Cloud Connectors：便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud config basic(一)]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13-SpringCloud%20Config%20basic(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[目录{:toc}config介绍SpringCloudConfig是SpringCloud创建的用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为客户端和服务端两部分。服务端也称为分布式配置中心，是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息，加密/解密信息等访问接口。而客户端则是微服务架构中各微服务应用或基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。搭建服务端配置添加pom依赖123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加yml文件配置123456789101112server: port: 3333spring: application: name: cloud-config cloud: config: server: git: uri: https://gitee.com/cocolar/springCloud.git #表示配置中心所在仓库的位置 username: #你的git账户 password: #你的git密码 在启动类中添加注解1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class CloudConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudConfigApplication.class, args); &#125;&#125; 运行运行项目，看是否报错。如果遇到指向maven仓库包的问题，可以删了重新update一下，可以解决。运行成功往下看 码云仓库创建文件在上面配置文件中 我自己在码云上创建了仓库，并分别上传了两个不同环境的配置文件。文件内容12info: profile: dev #开发环境 default 为默认环境 映射关系1234/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml或/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml或/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties这里的url会映射&#123;application&#125;-&#123;profile&#125;.yml对应的配置文件。&#123;label&#125;对应git上不同的分支，默认是master。 浏览器访问访问开发环境 http://localhost:3333/config-client/dev12345678910111213141516171819 &#123; &quot;name&quot;: &quot;config-client&quot;, &quot;profiles&quot;: [&quot;dev&quot;], &quot;label&quot;: null, &quot;version&quot;: &quot;1ca8d82b97e5d7b1bbc5c481d3961a388eb69bc3&quot;, &quot;state&quot;: null, &quot;propertySources&quot;: [&#123; &quot;name&quot;: &quot;https://gitee.com/cocolar/springCloud.git/config-client-dev.yml&quot;, &quot;source&quot;: &#123; &quot;info.profile&quot;: &quot;dev&quot; &#125; &#125;, &#123; &quot;name&quot;: &quot;https://gitee.com/cocolar/springCloud.git/config-client.yml&quot;, &quot;source&quot;: &#123; &quot;info.profile&quot;: &quot;default&quot; &#125; &#125;]&#125; 访问默认环境 http://localhost:3333/config-client.yml12info: profile: default 本地存储配置服务器在从git中获取到配置信息后，实际上会存储一份在config-server的文件系统，也就是复制一份在本地存储。 在控制台会看到添加一份到本地12Adding property source: file:/C:/Users/AMBERS~1.LI/AppData/Local/Temp/config-repo-1810577200124652408/config-client.yml 当你断掉网络时，发现获取信息是正常显示的，但是控制台会输出无法连接远端git1Could not fetch remote for master remote: https://gitee.com/cocolar/springCloud.git 显示的信息就是从本地获取的。 搭建客户端配置新建一个SpringBoot项目，命名cloud-config-client 引入依赖1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 添加bootstrap.yml 被配置，不是application.yml文件这些属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为config的相关配置会先于application.properties，而bootstrap.yml的加载也是先于application.yml123456789server: port: 4444spring: application: name: config-client #application的名字 cloud: config: profile: dev uri: http://localhost:3333/ # 服务配置段的地址 启动类不做改变123456789import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class CloudConfigClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudConfigClientApplication.class, args); &#125;&#125; 创建controller层访问1234567891011121314151617181920212223242526import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.core.env.Environment;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RefreshScopepublic class InfoController &#123; @Value(&quot;$&#123;info.profile&#125;&quot;) private String info; @GetMapping(&quot;/info&quot;) public String info() &#123; return this.info; &#125; //另一种方法 @Autowired private Environment environment; @GetMapping(&quot;/getinfo&quot;) public String name_env()&#123; return environment.getProperty(&quot;info.profile&quot;,&quot;undefine&quot;); &#125;&#125; 浏览器访问http://localhost:4444/getinfo显示 dev 客户端从配置管理中获取配置流程： 应用启动，根据bootstrap.properties中配置的应用名{application}、环境名{profile}、分支名{label}，行配置中心获取配置信息。ConfigServer根据自己维护的Git仓库信息和客户端传递过来的配置定位信息去查找配置信息。通过git clone命令将找到的配置信息下载到ConfigServer的文件系统中。ConfigServer创建Spring的ApplicationContext实例，并从git本地仓库中加载配置文件，最后将这些配置文件内容读取出来返回给客户端客户端应用在获得外部配置文件后加载到客户端ApplicationContext实例，该配置内容的优先级高于客户端Jar包内部的配置内容，所以在Jar包中重复的内容将不再被加载。 架构 配置高可用配置中心在微服务架构中，基本每一个服务都会配置成高可用的，配置中心也一样。对上面的config-server进行改造，添加eureka的依赖，是其作为服务在服务注册中心注册。 改造配置服务中心添加依赖1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在启动类上添加@EnableEurekaClient注解开启服务发现功能，使其成为eureka的一个客户端 改造配置客户中心添加依赖1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在启动类上添加@EnableDiscoveryClient注解在bootstrap.yml添加配置12345678910111213141516server: port: 4444spring: application: name: config-client cloud: config: profile: dev uri: http://localhost:3333/ discovery: # enabled: true #开启通过服务访问配置服务中心 serviceId: cloud-config #指定注册的配置服务的名字eureka: client: serviceUrl: defaultZone: http://localhost:1111/eureka/ # 指定服务注册中心 运行服务发现两个服务已经注册运行之前的controller层，正常显示值dev]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud RabbitMQ basic(一)]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-SpringCloud%20RabbitMQ%20basic(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[目录{:toc}AMQP在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。RabbitMQAMQP 是一种协议， RabbitMQ是一个由erlang开发的AMQP的开源实现，目前使用比较广泛的MQ有RabbitMQ,ActiveMQ,KafKa等等，其中ActiveMQ是基于JMS的一个开源实现，JMS 是一个接口标准或者说是一个API消息服务的规范（JAVA Message Service，java消息服务），KafKa是一种高吞吐量的分布式发布订阅消息系统，通常有吞吐量需求的日志处理和日志聚合应用会使用Kafka，性能要优于Rabbit,但是稳定性和可靠性相对而言RabbitMQ要成熟一些。安装下载Erlang：http://www.erlang.org/downloads下载rabbitMQ:http://www.rabbitmq.com/download.html安装完成后进行配置：Erlang 首先需要保证ERLANG_HOME环境配置正确 在环境变量中添加 ERLANG_HOME的路劲，如D:\Program Files\erl6.3 然后在PATH中添加%ERLANG_HOME%\bin 在cmd中输入erl ，如果能弹出erlang shell界面则表示配置正确了 rabbitMQ 配置RabbitMQ 打开命令行模式cmd： cd C:\rabbitmq\RabbitMQ\Server\rabbitmq_server-3.0.0\sbin 依次输入： 1. ./rabbitmq-plugins.bat enable rabbitmq_management 2. ./rabbitmq-service.bat stop 3.rabbitmq-service.bat install 这句话没用，提示：RabbitMQ service is already present - onlyupdating service parameters 4. ./rabbitmq-service.bat start 重新 start install stop 在执行第一个语句就能进去网页。 打开浏览器登录：http://127.0.0.1:15672 55672好像也可以，直接跳转到下列位置 http://127.0.0.1:15672/#/ 账号和密码都是guest Admin选显卡，可以创建一个springcloud账户，tags是rabbitmq的角色分类。 快速搭建基本工程添加依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建自己的springcloud账户在admin选项卡中进行创建点击创建好的账户，设置virtual hosts ,否则一会链接会出错创建好的样子 配置yml文件端口就是5672，不是15672，这个地方坑了我….12345678910server: port: 6666spring: application: name: cloud-rabbitmq rabbitmq: host: localhost port: 5672 # username: springcloud password: springcloud 配置消息生产者123456789101112131415161718import java.util.Date;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class Sender &#123; @Autowired private AmqpTemplate rabbitTemplate; public void send() &#123; String context = &quot;hello&quot; +new Date(); System.out.println(&quot;sender:&quot;+context); this.rabbitTemplate.convertAndSend(&quot;hello&quot;,context); &#125;&#125; 配置消息消费者12345678910111213import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues=&quot;hello&quot;)public class Receiver &#123; @RabbitHandler public void process(String hello) &#123; System.out.println(&quot;receiver:&quot;+hello); &#125;&#125; 配置基本配置类123456789101112import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RabbitConfig &#123; @Bean public Queue helloQueue() &#123; return new Queue(&quot;hello&quot;); &#125;&#125; 创建测试类123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.List;import java.util.concurrent.Future;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import com.example.demo.util.Sender;@RunWith(SpringRunner.class)@SpringBootTestpublic class RabbitmqApplicationTests &#123; @Autowired private Sender sender; @Test public void contextLoads() &#123; &#125; @Test public void hello() throws Exception&#123; sender.send(); &#125; &#125; 项目结构图 启动项目看到RabbitMQ Connections和Channels 连接条目在启动测试类 控制台输出：sender:helloThu Apr 12 15:40:51 CST 2018切换到主控制台输出：receiver:helloThu Apr 12 15:40:51 CST 2018]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[In Jekyll add gitment(添加评论系统)]]></title>
    <url>%2F2018%2F04%2F03%2F2018-04-03-In%20Jekyll%20add%20gitment%2F</url>
    <content type="text"><![CDATA[目录{:toc}在之前搭建的Jekyll上添加评论系统（gitment）网上很多第三方系统，不是被墙就是被关闭，所以借鉴一篇博客搭建国内大神写的gitment系统https://blog.csdn.net/ggabcda/article/details/77141221这是国内大神的项目主页github.com/imsun/gitment 申请一个Github OAuth ApplicationGithub头像下拉菜单 &gt; Settings &gt; 左边Developer settings下的OAuth Application &gt; Register a new application，填写相关信息： Application name, Homepage URL, Application description 都可以随意填写Authorization callback URL 一定要写自己Github Pages的URL填写完上述信息后按Register application按钮，得到Client ID和Client Secret 在jekyll博客调用gitment如gitment项目页Readme所示，在你需要添加评论系统的地方，一般是_layout/目录下的 post.html, 添加一下代码 1234567891011121314&gt;&lt;div id=&quot;gitmentContainer&quot;&gt;&lt;/div&gt;&gt;&lt;link rel=&quot;stylesheet&quot; &gt;href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;&gt;&lt;script &gt;src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.&gt;js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;&gt;var gitment = new Gitment(&#123;&gt; owner: &apos;Your GitHub username&apos;,&gt; repo: &apos;The repo to store comments&apos;,&gt; oauth: &#123;&gt; client_id: &apos;Your client ID&apos;,&gt; client_secret: &apos;Your client secret&apos;,&gt; &#125;,&gt;&#125;);&gt;gitment.render(&apos;gitmentContainer&apos;);&gt;&lt;/script&gt; 需要修改的有4个地方 Your GitHub username：填写你的Github Pages博客所在的github账户名The repo to store comments：填写用来存放评论的github仓库，由于评论是 通过issues来存放的，个人建议这里可以直接填Github Pages个人博客所在的仓库Your client ID：第1步所申请到的应用的Client IDYour client secret：第1步所申请到的应用的Client Secret填写完这4项把代码保存上传到github就可以了。 为每篇博文初始化评论系统由于gitment的原理是为每一遍博文以其URL作为标识创建一个github issue， 对该篇博客的评论就是对这个issue的评论。因此，我们需要为每篇博文初始化一下评论系统， 初始化后，你可以在你的github上会创建相对应的issue。 接下来，介绍一下如何初始化评论系统 上面第2步代码添加成功并上传后，你就可以在你的博文页下面看到一个评论框，还 有看到以下错误Error: Comments Not Initialized，提示该篇博文的评论系统还没初始化 点击Login with GitHub后，使用自己的github账号登录后，就可以在上面错误信息 处看到一个Initialize Comments的按钮(ps: 由于要求回调URL和当前地址一样，故第2步不能在本地调试， 需把代码先上传再调试) 点击Initialize Comments按钮后，就可以开始对该篇博文开始评论了， 同时也可以在对应的github仓库看到相应的issue 我有一页的博客初始化失败，暂时还没找到原因…]]></content>
      <categories>
        <category>jekyll</category>
        <category>gitment</category>
      </categories>
      <tags>
        <tag>jekyll gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud problem]]></title>
    <url>%2F2018%2F04%2F03%2F2018-04-03-SpringCloud%20problem%2F</url>
    <content type="text"><![CDATA[目录{:toc}搭建Springcloud基础模块并实现3个 服务注册中心 用户 商品,在用户往商品里传递值时，一直报415传不过去。123456String pro =JSON.toJSONString(product); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity&lt;String&gt; entity = new HttpEntity&lt;String&gt;(pro,headers); return restTemplate.postForEntity(&quot;http://demo-client/product/insertProduct&quot;,entity,String.class).getBody(); 要把Header 的ContentType 变成 UTF-8，要不识别不到，可以观察浏览器F12传过去的类型。随便放一张图片，显示要查看的位置 RestTemplate在put delete的时候没有返回值，可以用exchange()方法12345678 JSONObject jo = new JSONObject();jo.put(&quot;comyId&quot;, 4);jo.put(&quot;comName&quot;, &quot;pppp&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity&lt;JSONObject&gt; entity = new HttpEntity&lt;JSONObject&gt;(jo,headers);return restTemplate.exchange(&quot;http://demo-client/product/updateProductByPId&quot;,HttpMethod.PUT,entity,Object.class);]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Eureka(一)]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-SpringCloud%20Eureka(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[目录{:toc}SpringCloud介绍Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。微服务微服务架构(比如：netflix、dubbo)就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。SpringCloud的基础搭建服务注册这里我们会用到Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。我们这里的核心内容就是服务发现模块：Eureka。 首先正常创建项目，添加依赖包，勾选如图所示 pom.xml文件中可以看到添加了下面的依赖 12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行注册 123456789101112131415package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;//@EnableEurekaServer//@SpringBootApplicationpublic class TestRegApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestRegApplication.class, args); &#125;&#125; 写配置文件 在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，在application.yml进行配置。设置端口为1111123456789server: port: 1111 eureka: client: register-with-eureka: false fetch-registry: false serviceUrl: defaultZone: http://localhost:$&#123;server.port&#125;/eureka/ 运行项目，在浏览器中访问：http://localhost:1111/ 可以看到并没有客户端注册 创建服务提供者现在我们来创建提供服务的客户端，并且在服务中心注册自己。我们创建一个提供计算a+b的服务模块 重新创建工程,加入的依赖如下 pom.xml中主要依赖1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，才能实现Controller中对服务信息的输出。 12345678910111213141516package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\\@EnableDiscoveryClient\\@SpringBootApplicationpublic class TestServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestServiceApplication.class, args); &#125;&#125; 写配置文件 spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。注意spring.application.name属性的名称最好与启动类TestServiceApplication.java名称一致，否则可能出现错误123456789spring: application: name: test-serviceserver: port: 2223eureka: client: serviceUrl: defaultZone: http://localhost:1111/eureka/ 写controller接口,实现/add请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。 1234567891011121314151617181920212223242526272829package com.example.demo;import org.jboss.logging.Logger;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AddController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @RequestMapping(value = &quot;/add&quot; ,method = RequestMethod.GET) public Integer add(@RequestParam Integer a, @RequestParam Integer b) &#123; Integer r = a + b; client.getServices().forEach(id -&gt; &#123; client.getInstances(id).forEach(instance -&gt; &#123; logger.info(&quot;/add, host:&quot; + instance.getHost() + &quot;, service_id:&quot; + instance.getServiceId()+&quot; result:&quot; + r); &#125;); &#125;); return r; &#125;&#125; 先启动注册中心的服务，在启动该程序运行 http://localhost:1111/，可以看到有注册者了 我们还可以尝试访问服务提供者提供的接口，发现访问成功。返回正确结果，在控制台中可以看到我们打印的日志 ps:有的童鞋不知道运行多个程序，怎么切换console控制台，看图 停止服务，旁边的两个叉叉可以清空加载信息哦~ 问题：如果操作一遍发现有些解决不了的问题，可能是包冲突，版本不匹配引起的，建议统一版本 源码注册中心：https://github.com/FlyLesss/blogCode/tree/master/test-reg服务提供者: https://github.com/FlyLesss/blogCode/tree/master/test-service]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot AOP Problem(One)]]></title>
    <url>%2F2018%2F03%2F30%2F2018-03-30-Springboot%20AOP%20Problem(One)%2F</url>
    <content type="text"><![CDATA[目录{:toc}AOP 运行不进 @Before,直接进入@AfterReturing这个问题找了我好久，很奇怪为什么运行时进不去@Before,直接进到@AfterReturing，后来才发现是我把@Around方法里的pjp.proceed();注释掉了，导致进不去@Before的方法。具体运行的原理没搞懂…贴两张在网上找到的顺序图]]></content>
      <categories>
        <category>problem</category>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>problem,AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot Learn(Three)--Swagger]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-Springboot%20Learn(Three)%2F</url>
    <content type="text"><![CDATA[目录{:toc} Swagger介绍本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。 作用: 接口的文档在线自动生成。 功能测试。 Swagger是一组开源项目，其中主要要项目如下： Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。 Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。 Swagger-js: 用于JavaScript的Swagger实现。 Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。 Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。 Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。 Swagger使用的注解及其说明： @Api：用在类上，说明该类的作用。 @ApiOperation：注解来给API增加方法说明。 @ApiImplicitParams : 用在方法上包含一组参数说明。 @ApiImplicitParam：用来注解来给方法入参增加说明。 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 l code：数字，例如400 l message：信息，例如&quot;请求参数没填好&quot; l response：抛出异常的类 @ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候） l @ApiModelProperty：描述一个model的属性 准备工作添加Swagger依赖在maven的pom.xml文件中添加1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 添加后几个maven 中update下，把Force update选上 添加Swagger的配置类放在config包下1234567891011121314151617181920212223242526272829303132333435@Configuration@EnableSwagger2public class Swagger2Config &#123; private final String swagger2_api_basepackage = &quot;com.example.demo.web&quot;; private final String swagger2_api_title = &quot;用户-API&quot;; private final String swagger2_api_description = &quot;用户信息的api&quot;; private final String swagger2_api_contact = &quot;ls&quot;; private final String swagger2_api_version = &quot;1.0&quot;; /** * createRestApi * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(swagger2_api_basepackage)) .paths(PathSelectors.any()) .build(); &#125; /** * apiInfo * @return */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(swagger2_api_title) .description(swagger2_api_description) .contact(swagger2_api_contact) .version(swagger2_api_version) .build(); &#125; &#125; @Configuration配置注解@EnableSwagger2启用Swagger注解，一定要加上swagger2_api_basepackage写的是controller层的包名，也就是web层，也是最上面的一层，跟前端界面进行接收和返回值得一层。 代码的修改bean层实体类Partner就变成了这样@ApiModelProperty(value = &quot;partnerId&quot;,dataType = &quot;String&quot;)中的value是在界面上显示这个属性的含义，所以可以用中文来标识123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.example.demo.bean;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(value = &quot;Partner的实体，----》&quot;,reference = &quot;我是参考&quot;)public class Partner &#123; @ApiModelProperty(value = &quot;partnerId&quot;,dataType = &quot;String&quot;) private String partnerId; @ApiModelProperty(value = &quot;userType&quot;,dataType = &quot;String&quot;) private String userType; @ApiModelProperty(value = &quot;loginAccount&quot;,dataType = &quot;String&quot;) private String loginAccount; @ApiModelProperty(value = &quot;password&quot;,dataType = &quot;String&quot;) private String password; @ApiModelProperty(value = &quot;name&quot;,dataType = &quot;String&quot;) private String name; @ApiModelProperty(value = &quot;mobile&quot;,dataType = &quot;String&quot;) private String mobile; @ApiModelProperty(value = &quot;email&quot;,dataType = &quot;String&quot;) private String email; @ApiModelProperty(value = &quot;idcard&quot;,dataType = &quot;String&quot;) private String idcard; @ApiModelProperty(value = &quot;companyName&quot;,dataType = &quot;String&quot;) private String companyName; @ApiModelProperty(value = &quot;companyAddress&quot;,dataType = &quot;String&quot;) private String companyAddress; public String getPartnerId() &#123; return partnerId; &#125; public void setPartnerId(String partnerId) &#123; this.partnerId = partnerId; &#125; public String getUserType() &#123; return userType; &#125; public void setUserType(String userType) &#123; this.userType = userType; &#125; public String getLoginAccount() &#123; return loginAccount; &#125; public void setLoginAccount(String loginAccount) &#123; this.loginAccount = loginAccount; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getIdcard() &#123; return idcard; &#125; public void setIdcard(String idcard) &#123; this.idcard = idcard; &#125; public String getCompanyName() &#123; return companyName; &#125; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public String getCompanyAddress() &#123; return companyAddress; &#125; public void setCompanyAddress(String companyAddress) &#123; this.companyAddress = companyAddress; &#125; @Override public String toString() &#123; return &quot;User [partnerId=&quot; + partnerId + &quot;, userType=&quot; + userType + &quot;, loginAccount=&quot; + loginAccount + &quot;, password=&quot; + password + &quot;, name=&quot; + name + &quot;, mobile=&quot; + mobile + &quot;, email=&quot; + email + &quot;, idcard=&quot; + idcard + &quot;, companyName=&quot; + companyName + &quot;, companyAddress=&quot; + companyAddress + &quot;]&quot;; &#125;&#125; web层的修改这里增加了API的说明@ApiOperation，以及参数的说明ApiImplicitParam，可以在界面上进行显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.demo.web;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.example.demo.bean.Partner;import com.example.demo.service.impl.PartnerService;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiOperation;//RestController：默认类中的方法都会以json的格式返回。@RestController@RequestMapping(&quot;/partner&quot;)public class PartnerController &#123; @Autowired PartnerService partnerService; //查询 @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;获取列表&quot;) @RequestMapping(value=&quot;/findPartner&quot;,method=&#123;RequestMethod.GET&#125;) public List&lt;Partner&gt; findPartner() &#123; // TODO Auto-generated method stub return partnerService.findPartner(); &#125; @ApiOperation(value=&quot;获取单个用户信息&quot;, notes=&quot;获取用户&quot;) @RequestMapping(value=&quot;/findPartnerById&quot;,method=&#123;RequestMethod.GET&#125;) public Partner findPartnerById(@RequestParam(value = &quot;partnerId&quot;, required = true)String partnerId) &#123; // TODO Auto-generated method stub return partnerService.findPartnerById(partnerId); &#125; @ApiOperation(value=&quot;增加用户信息&quot;, notes=&quot;增加用户&quot;) @RequestMapping(value=&quot;/insertPartner&quot;,method=&#123;RequestMethod.POST&#125;) public int insertPartner(@RequestBody Partner partner) &#123; // TODO Auto-generated method stub return partnerService.insertPartner(partner); &#125; @ApiOperation(value=&quot;更新用户信息&quot;, notes=&quot;更新用户&quot;) @ApiImplicitParam(name = &quot;partner&quot;, value = &quot;partner实体&quot;, required = true, dataType = &quot;Partner&quot;) @RequestMapping(value=&quot;/updatePartner&quot;,method=&#123;RequestMethod.PUT&#125;) public int updatePartner(@RequestBody Partner partner) &#123; // TODO Auto-generated method stub return partnerService.updatePartner(partner); &#125; @ApiOperation(value=&quot;删除用户信息&quot;, notes=&quot;删除&quot;) @RequestMapping(value=&quot;/deletePartnerById&quot;,method=&#123;RequestMethod.DELETE&#125;) public int deletePartnerById(@RequestParam(value = &quot;partnerId&quot;, required = true) String partnerId) &#123; // TODO Auto-generated method stub return partnerService.deletePartnerById(partnerId); &#125;&#125; 测试验证浏览器输入http://localhost:8080/swagger-ui.html端口默认是8080，没有修改过的点击try it out!进行对各种API的测试，非常方便点击查看源码地址]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot Learn(二)--CURD]]></title>
    <url>%2F2018%2F03%2F24%2F2018-03-24-Springboot%20Learn(two)%2F</url>
    <content type="text"><![CDATA[目录{:toc}前言上一篇文章已经介绍过用Springboot搭建HelloWorld,今天来用Springboot进行对Mysql数据库的增删改查操作基于RestFul规范。怎么创建项目见上一篇文章创建数据库123456789101112131415161718192021222324252627CREATE TABLE `ec_partner` ( `PARTNER_ID` varchar(32) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;合作伙伴编号&apos;, `USER_TYPE` varchar(2) NOT NULL COMMENT &apos;用户类型(1个人、2企业、3商户、4店小二)&apos;, `LOGIN_ACCOUNT` text NOT NULL COMMENT &apos;登录账号&apos;, `PASSWORD` text NOT NULL COMMENT &apos;密码&apos;, `NAME` text COMMENT &apos;姓名&apos;, `MOBILE` text COMMENT &apos;手机号码&apos;, `EMAIL` text COMMENT &apos;邮箱地址&apos;, `IDCARD` text COMMENT &apos;证件号码&apos;, `COMPANY_NAME` text COMMENT &apos;公司名称&apos;, `COMPANY_ADDRESS` text COMMENT &apos;公司地址&apos;, PRIMARY KEY (`PARTNER_ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;合作伙伴信息&apos;;--添加数据INSERT INTO `ec_partner` VALUES (&apos;11&apos;, &apos;11&apos;, &apos;11@11&apos;, &apos;11&apos;, &apos;11&apos;, &apos;11&apos;, &apos;11&apos;, &apos;11&apos;, &apos;11&apos;, &apos;11&apos;);INSERT INTO `ec_partner` VALUES (&apos;15&apos;, &apos;15&apos;, &apos;15&apos;, &apos;15&apos;, &apos;15&apos;, &apos;15&apos;, &apos;15&apos;, &apos;15&apos;, &apos;15&apos;, &apos;15&apos;);INSERT INTO `ec_partner` VALUES (&apos;16&apos;, &apos;16&apos;, &apos;16&apos;, &apos;16&apos;, &apos;16&apos;, &apos;16&apos;, &apos;16&apos;, &apos;16&apos;, &apos;16&apos;, &apos;16&apos;);INSERT INTO `ec_partner` VALUES (&apos;33&apos;, &apos;33&apos;, &apos;33&apos;, &apos;33&apos;, &apos;33&apos;, &apos;33&apos;, &apos;33&apos;, &apos;33&apos;, &apos;33&apos;, &apos;33&apos;);INSERT INTO `ec_partner` VALUES (&apos;44&apos;, &apos;44&apos;, &apos;44&apos;, &apos;44&apos;, &apos;44&apos;, &apos;44&apos;, &apos;44&apos;, &apos;44&apos;, &apos;44&apos;, &apos;44&apos;);INSERT INTO `ec_partner` VALUES (&apos;55&apos;, &apos;56&apos;, &apos;56&apos;, &apos;56&apos;, &apos;56&apos;, &apos;56&apos;, &apos;56&apos;, &apos;56&apos;, &apos;56&apos;, &apos;56&apos;);INSERT INTO `ec_partner` VALUES (&apos;66&apos;, &apos;66&apos;, &apos;66&apos;, &apos;66&apos;, &apos;66&apos;, &apos;66&apos;, &apos;66&apos;, &apos;66&apos;, &apos;66&apos;, &apos;66&apos;);INSERT INTO `ec_partner` VALUES (&apos;678&apos;, &apos;3&apos;, &apos;678&apos;, &apos;678&apos;, &apos;678&apos;, &apos;678&apos;, &apos;678&apos;, &apos;678&apos;, &apos;678&apos;, &apos;678&apos;);INSERT INTO `ec_partner` VALUES (&apos;77&apos;, &apos;77&apos;, &apos;77&apos;, &apos;77&apos;, &apos;77&apos;, &apos;77&apos;, &apos;77&apos;, &apos;77&apos;, &apos;77&apos;, &apos;77&apos;);INSERT INTO `ec_partner` VALUES (&apos;88&apos;, &apos;88&apos;, &apos;88&apos;, &apos;88&apos;, &apos;88&apos;, &apos;88&apos;, &apos;88&apos;, &apos;88&apos;, &apos;88&apos;, &apos;88&apos;);INSERT INTO `ec_partner` VALUES (&apos;99&apos;, &apos;99&apos;, &apos;99&apos;, &apos;99&apos;, &apos;99&apos;, &apos;99&apos;, &apos;99&apos;, &apos;99&apos;, &apos;99&apos;, &apos;99&apos;); 配置application.properties文件yml文件对格式规范很有要求，多敲一个空格很可能造成错误，最好复制本段代码我的数据库名字叫user123456spring: datasource: url: jdbc:mysql://localhost:3306/user?characterEncoding=UTF-8&amp;useSSL=false username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver 搭建基础工程把包的结构创建好，基于MVC模式bean：放实体类，包括get和set方法mapper: 放dao层和xml文件service: 业务处理层web: 控制层config: 放配置的类util: 工具层编写代码的顺序是 bean –&gt; mapper –&gt;service –&gt;web 编写代码首先是bean层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.example.demo.bean;public class Partner &#123; private String partnerId; private String userType; private String loginAccount; private String password; private String name; private String mobile; private String email; private String idcard; private String companyName; private String companyAddress; public String getPartnerId() &#123; return partnerId; &#125; public void setPartnerId(String partnerId) &#123; this.partnerId = partnerId; &#125; public String getUserType() &#123; return userType; &#125; public void setUserType(String userType) &#123; this.userType = userType; &#125; public String getLoginAccount() &#123; return loginAccount; &#125; public void setLoginAccount(String loginAccount) &#123; this.loginAccount = loginAccount; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getIdcard() &#123; return idcard; &#125; public void setIdcard(String idcard) &#123; this.idcard = idcard; &#125; public String getCompanyName() &#123; return companyName; &#125; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public String getCompanyAddress() &#123; return companyAddress; &#125; public void setCompanyAddress(String companyAddress) &#123; this.companyAddress = companyAddress; &#125; @Override public String toString() &#123; return &quot;User [partnerId=&quot; + partnerId + &quot;, userType=&quot; + userType + &quot;, loginAccount=&quot; + loginAccount + &quot;, password=&quot; + password + &quot;, name=&quot; + name + &quot;, mobile=&quot; + mobile + &quot;, email=&quot; + email + &quot;, idcard=&quot; + idcard + &quot;, companyName=&quot; + companyName + &quot;, companyAddress=&quot; + companyAddress + &quot;]&quot;; &#125;&#125; mapper层两个class文件，一个.java 另一个.xml,两个文件的文件名要一样这里会用到一个mybatis的注解@MapperPartnerMapper.java12345678910111213141516171819ackage com.example.demo.mapper;import java.util.List;import org.apache.ibatis.annotations.Mapper;import com.example.demo.bean.Partner;@Mapperpublic interface PartnerMapper &#123; //注意下命名规范 List&lt;Partner&gt; findPartner(); Partner findPartnerById( String partnerId); int insertPartner(Partner user); int updatePartner(Partner user); int deletePartnerById(String partnerId);&#125; PartnerMapper.xml这里介绍下resultMap：resultMap是Mybatis最强大的元素，它可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中。123456789101112131415&lt;!-resultMap包含的元素：--&gt;&lt;!--column不做限制，可以为任意表的字段，而property须为type 定义的pojo属性--&gt;&lt;resultMap id=&quot;唯一的标识&quot; type=&quot;映射的pojo对象&quot;&gt; &lt;id column=&quot;表的主键字段，或者可以为查询语句中的别名字段&quot; jdbcType=&quot;字段类型&quot; property=&quot;映射pojo对象的主键属性&quot; /&gt; &lt;result column=&quot;表的一个字段（可以为任意表的一个字段）&quot; jdbcType=&quot;字段类型&quot; property=&quot;映射到pojo对象的一个属性（须为type定义的pojo对象中的一个属性）&quot;/&gt; &lt;association property=&quot;pojo的一个对象属性&quot; javaType=&quot;pojo关联的pojo对象&quot;&gt; &lt;id column=&quot;关联pojo对象对应表的主键字段&quot; jdbcType=&quot;字段类型&quot; property=&quot;关联pojo对象的主席属性&quot;/&gt; &lt;result column=&quot;任意表的字段&quot; jdbcType=&quot;字段类型&quot; property=&quot;关联pojo对象的属性&quot;/&gt; &lt;/association&gt; &lt;!-- 集合中的property须为oftype定义的pojo对象的属性--&gt; &lt;collection property=&quot;pojo的集合属性&quot; ofType=&quot;集合中的pojo对象&quot;&gt; &lt;id column=&quot;集合中pojo对象对应的表的主键字段&quot; jdbcType=&quot;字段类型&quot; property=&quot;集合中pojo对象的主键属性&quot; /&gt; &lt;result column=&quot;可以为任意表的字段&quot; jdbcType=&quot;字段类型&quot; property=&quot;集合中的pojo对象的属性&quot; /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 注意下面#{*****}应为bean里对应的属性名，而不是表名123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.PartnerMapper&quot;&gt; &lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.example.demo.bean.Partner&quot;&gt; &lt;result column=&quot;PARTNER_ID&quot; property=&quot;partnerId&quot;&gt;&lt;/result&gt; &lt;result column=&quot;USER_TYPE&quot; property=&quot;userType&quot;&gt;&lt;/result&gt; &lt;result column=&quot;LOGIN_ACCOUNT&quot; property=&quot;loginAccount&quot;&gt;&lt;/result&gt; &lt;result column=&quot;PASSWORD&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;NAME&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;MOBILE&quot; property=&quot;mobile&quot;&gt;&lt;/result&gt; &lt;result column=&quot;EMAIL&quot; property=&quot;email&quot;&gt;&lt;/result&gt; &lt;result column=&quot;IDCARD&quot; property=&quot;idcard&quot;&gt;&lt;/result&gt; &lt;result column=&quot;COMPANY_NAME&quot; property=&quot;companyName&quot;&gt;&lt;/result&gt; &lt;result column=&quot;COMPANY_ADDRESS&quot; property=&quot;companyAddress&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=&quot;findPartner&quot; resultMap=&quot;userResultMap&quot; parameterType=&quot;java.lang.String&quot;&gt; select * from ec_partner &lt;/select&gt; &lt;select id=&quot;findPartnerById&quot; resultMap=&quot;userResultMap&quot; parameterType=&quot;java.lang.String&quot;&gt; select * from ec_partner where PARTNER_ID=#&#123;partnerId&#125; &lt;/select&gt; &lt;insert id=&quot;insertPartner&quot; parameterType=&quot;com.example.demo.bean.Partner&quot;&gt; insert into ec_partner( PARTNER_ID, USER_TYPE, LOGIN_ACCOUNT, PASSWORD, NAME, MOBILE, EMAIL, IDCARD, COMPANY_NAME, COMPANY_ADDRESS )values( #&#123;partnerId&#125;, #&#123;userType&#125;, #&#123;loginAccount&#125;, #&#123;password&#125;, #&#123;name&#125;, #&#123;mobile&#125;, #&#123;email&#125;, #&#123;idcard&#125;, #&#123;companyName&#125;, #&#123;companyAddress&#125; ) &lt;/insert&gt; &lt;delete id=&quot;deletePartnerById&quot; parameterType=&quot;java.lang.String&quot;&gt; delete from ec_partner where PARTNER_ID=#&#123;partnerId&#125; &lt;/delete&gt;&lt;/mapper&gt; service层service.api1234567891011121314package com.example.demo.service.api;import java.util.List;import com.example.demo.bean.Partner;public interface IPartnerService &#123; List&lt;Partner&gt; findPartner(); Partner findPartnerById( String partnerId); int insertPartner(Partner user); int updatePartner(Partner user); int deletePartnerById(String partnerId);&#125; service.impl这里会用到两个注解@Service和@Autowired1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.demo.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.example.demo.bean.Partner;import com.example.demo.mapper.PartnerMapper;import com.example.demo.service.api.IPartnerService;@Servicepublic class PartnerService implements IPartnerService &#123; @Autowired PartnerMapper partnerMapper; @Override public List&lt;Partner&gt; findPartner() &#123; // TODO Auto-generated method stub return partnerMapper.findPartner(); &#125; @Override public Partner findPartnerById(String partnerId) &#123; // TODO Auto-generated method stub return partnerMapper.findPartnerById(partnerId); &#125; @Override public int insertPartner(Partner user) &#123; // TODO Auto-generated method stub return partnerMapper.insertPartner(user); &#125; @Override public int updatePartner(Partner user) &#123; // TODO Auto-generated method stub return partnerMapper.updatePartner(user); &#125; @Override public int deletePartnerById(String partnerId) &#123; // TODO Auto-generated method stub return partnerMapper.deletePartnerById(partnerId); &#125;&#125; web层这里用到两个注解@RestController和@RequestMapping(&quot;***&quot;)参数两个注解 @RequestParam和@RequestBody123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.demo.web;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.example.demo.bean.Partner;import com.example.demo.service.impl.PartnerService;//RestController：默认类中的方法都会以json的格式返回。@RestController@RequestMapping(&quot;/partner&quot;)public class PartnerController &#123; @Autowired PartnerService partnerService; @RequestMapping(value=&quot;/findPartner&quot;,method=&#123;RequestMethod.GET&#125;) public List&lt;Partner&gt; findPartner() &#123; // TODO Auto-generated method stub return partnerService.findPartner(); &#125; @RequestMapping(value=&quot;/findPartnerById&quot;,method=&#123;RequestMethod.GET&#125;) public Partner findPartnerById(@RequestParam(value = &quot;partnerId&quot;, required = true)String partnerId) &#123; // TODO Auto-generated method stub return partnerService.findPartnerById(partnerId); &#125; @RequestMapping(value=&quot;/insertPartner&quot;,method=&#123;RequestMethod.POST&#125;) public int insertPartner(@RequestBody Partner user) &#123; // TODO Auto-generated method stub return partnerService.insertPartner(user); &#125; @RequestMapping(value=&quot;/updatePartner&quot;,method=&#123;RequestMethod.PUT&#125;) public int updatePartner(@RequestBody Partner user) &#123; // TODO Auto-generated method stub return partnerService.updatePartner(user); &#125; @RequestMapping(value=&quot;/deletePartnerById&quot;,method=&#123;RequestMethod.DELETE&#125;) public int deletePartnerById(@RequestParam(value = &quot;partnerId&quot;, required = true) String partnerId) &#123; // TODO Auto-generated method stub return partnerService.deletePartnerById(partnerId); &#125;&#125; 测试结果获取全部信息获取单个信息更新，增加…可以用postman工具测，我这里就不演示了，下篇文章会演示swagger，一个界面测试的插件点击查看源码]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot Learn(一)--HelloWorld]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-Springboot%20Learn(one)%2F</url>
    <content type="text"><![CDATA[目录{:toc}Springboot介绍使用Spring Boot可以让我们快速创建一个基于Spring的项目，而让这个Spring项目跑起来我们只需要很少的配置就可以。Springboot功能介绍1.独立运行的Spring项目2.提供starter简化Maven配置3.Spring Boot可以内嵌Tomcat，这样我们无需以war包的形式部署项目。4.自动配置Spring 5.我目前理解到的就这些，以后了解了在补充…Springboot安装环境和运行软件1.安装JDK我的jdk安装目录是1C:\Program Files\Java\jdk1.8.0_152 所以环境变量中配置(一定要查看对应的文件中是否有配置的文件)123JAVA_HOME=C:\Program Files\Java\jdk1.8.0_152path=%JAVA_HOME%\binCLASSPATH=%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 环境配好后，安装软件下载地址 建立第一个HelloWorld1.File—&gt;New—&gt;Spring Starter Project2.都是默认点击Next3.把需要用到的包勾上，我这里经常使用这几个，就有显示经常使用的包。DevTools:热启动，就是不用重新加载服务器Mybatis:Mybatis的依赖Mysql:mysql的依赖Web:spring的核心包Validation:校验依赖点击Finish这里第一次建，需要些时间，他需要从网上下载依赖包。可以查看右下角的进度条。4.建好的工程如图DemoTestApplication.java是程序的启动入口application.yml或者application.properties都可以，是配置属性的。5.DemoTestApplication.java这个类有一个@SpringBootApplication注解，这是整个Spring Boot的核心注解，它的目的就是开启Spring Boot的自动配置。12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;@SpringBootApplication(exclude= &#123;DataSourceAutoConfiguration.class&#125;)public class DemoTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoTestApplication.class, args); &#125;&#125; exclude= {DataSourceAutoConfiguration.class}没有这个属性会报错 1234567891011***************************APPLICATION FAILED TO START***************************Description:Failed to auto-configure a DataSource: &apos;spring.datasource.url&apos; is not specified and no embedded datasource could be auto-configured.Reason: Failed to determine a suitable driver classAction:Consider the following: If you want an embedded database (H2, HSQL or Derby), please put it on the classpath. If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active). 要排除此类的autoconfig。启动以后就可以正常运行。 这是因为添加了数据库组件，所以autoconfig会去读取数据源配置，而我新建的项目还没有配置数据源，所以会导致异常出现6.新建一个Controller类，实现一个HelloWorld1234567891011import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//RestController：默认类中的方法都会以json的格式返回。@RestControllerpublic class DemoController &#123; @RequestMapping(&quot;/hello&quot;) String index()&#123; return &quot;Hello Spring Boot!&quot;; &#125;&#125; 7.右键项目运行 Run as —&gt;Spring boot App8.浏览器测试点击查看源码]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git知识点及常用命令]]></title>
    <url>%2F2017%2F09%2F26%2F2017-09-26-git%20common%20commands%2F</url>
    <content type="text"><![CDATA[本地仓库名要和远程仓库名一致 否则pull不下来创建本地仓库比如 Amber.Ligit init 初始化本地仓库 创建隐藏文件 ./gitgit remote -v 查看远程仓库链接地址 git remote add origin(这个随意 自己取 以后就用这个名称代替远程仓库) SSH地址git pull origin master(远程仓库master分支) 先从远程仓库pull到本地 在进行上传操作在本地添加要上传的文件git add .git commit -m &quot;输入提交的提示信息&quot;git status 可以查看缓冲池是干净的git push origin master 目录{:toc}Git常用命令查看、添加、提交、删除、找回，重置修改文件git help &lt;command&gt; 显示command的helpgit show# 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt;# 将工作文件修改提交到本地暂存区git add .# 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached# 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a# 将git add, git rm和git ci等操作都合并在一起做git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录git log -p # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat#查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理 查看、切换、创建和删除分支git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch# 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin# 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push# push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理 GitHubgit remote -v# 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库创建远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~# 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init# 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop# 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c# 基础知识点补充]]></title>
    <url>%2F2017%2F09%2F26%2F2017-09-26-C%23%20basics%20replenish%2F</url>
    <content type="text"><![CDATA[目录{:toc}导语：之前C#很薄弱，熟悉了一些后，总结下C#知识点，知识点不分先后顺序，看到哪总结到哪。1.全国唯一标识符GUID ：12345string strguid = Guid.NewGuid().ToString();//57d99d89-caab-482a-a0e9-a0a803eed3ba 生成标准的标志符 (36位标准)strguid = Guid.NewGuid().ToString(&quot;D&quot;);//57d99d89-caab-482a-a0e9-a0a803eed3ba 同上，也是标准的标识符 (36位标准) strguid = Guid.NewGuid().ToString(&quot;N&quot;);//38bddf48f43c48588e0d78761eaa1ce6 生成32位无符号标识符 strguid = Guid.NewGuid().ToString(&quot;B&quot;);//&#123;09f140d5-af72-44ba-a763-c861304b46f8&#125; 生成(38位:含大括号) strguid = Guid.NewGuid().ToString(&quot;N&quot;);//(778406c2-efff-4262-ab03-70a77d09c2b5) 生成(38位:含小括号) 2.Math.Round 四舍六入五取偶(银行家算法)到指定小数点位数 C# Math.Round 文章 3.string.IsNullOrEmpty，string.IsNullOrWhiteSpace 区别：IsNullOrEmpty: “\t”这样的字符就返回false了,所以要检测这种空白字符用IsNullOrWhiteSpace 4.对象初始化器（必须有一个默认的无参构造函数）12345Curry tastcurry = new Curry &#123; style = &quot;cvf&quot;, spiciness = 8 &#125; 5.var关键字（必须初始化，否则无法进行推理）1var myVar = 5; 6.匿名类型7.==,equals区别 1、基本数据类型比较 ==和Equals都比较两个值是否相等。相等为true 否则为false； 2、引用对象比较 ==和Equals都是比较栈内存中的地址是否相等 。相等为true 否则为false； 8.命名参数(选择使用哪个参数,在方法中有多个可选参数时，在调用的时候选择)12&lt;paramName&gt; ： &lt;paramValue&gt;myMethod(value,count:number); 9.Lambda表达式 匿名类的简写 Lambda 表达式是一个委托 10.LINQ 查询1234567伪代码 from [type] id in source [join [type] id in source on expr equals expr [into subGroup]] [from [type] id in source | let id = expr | where condition] [orderby ordering,ordering,ordering...] select expr | group expr by key [into id query] 1234 from u in users let number = Int32.Parse(u.Username.Substring(u.Username.Length - 1)) where u.ID &lt; 9 &amp;&amp; number % 2 == 0 select u 11.类型转换 隐式转换 显示转换(溢出检查 checked unchecked) Convert命令显示转换 as 引用类型转换 12.枚举 enmu 默认是int型1234enum country : string&#123; English = &quot;hello&quot;, Chinese = &quot;你好&quot; &#125; 13.参数关键字 ref 引用参数，在函数中的改变会改变调用函数的值 out 输出参数,使用方式同ref，也是该参数的值将返回给函数调用中的使用变量，使用时，必须把他看成尚未赋值，赋值会在执行中丢失13.可删除的对象IDisposable 接口 调用的必须实现其Dispose方法， 当不需要某个对象时，就会调用这个方法释放资源，否则要等到垃圾对象回收调用析构方法才会释放资源。using关键字可以在代码块初始化使用重要资源对象，在这个代码块结尾，会自动调用Dispose()方法。在方法中调用1234using (Class1 cls1 = new Class1(), cls2 = new Class1()) &#123; // the code using cls1, cls2 &#125; // 14.多态性：把某个派生类的变量赋值给基本类型的变量。 比如Animal 是基类 ，有一个 EatFood()方法，派生类是Cow，和Chicken。但是不能以相同点的方法调用派生类自定义的方法。1234Cow mycow = new Cow(); Chicken myChicken = new Chicken(); Animal myAnimal = mycow; myAnimal.EatFood(); 接口的多态性 把Animal提供的EatFood放在IConsume接口上，Cow和Chicken也支持这个接口并实现这个方法代码的基础上12345Cow mycow = new Cow();Chicken myChicken = new Chicken();IConsume consumeInterface;consumeInterface = myCow;consumeInterface.EatFood(); 15.GetType() 和 typeof 都是获取对象的类型 GetType() 是方法，typeof是C#的运算符16.封箱和拆箱封箱是把值类型转换为System.Object类型，或者转换为由值类型实现的接口类型; 拆箱相反.(值类型是要放在栈上的，而object是引用类型，它需要放在堆上) 123456装箱： int age = 24; object refAge= age;拆箱： int newAge = (int) refAge; string newAge =(String) refAge; 16.可空类型，比如 int 默认为0，可以使他默认为null int ? number;17.??运算符 op1 ?? op2 : 如果第一个操作数不是null，则就等于第一个，否则等于第二个等同于 op1 == null ? po1 : op2 推荐文章 LINQ 30分钟]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# delegate and event]]></title>
    <url>%2F2017%2F08%2F17%2F2017-09-22-delegate%20and%20event%2F</url>
    <content type="text"><![CDATA[小白认真的看了看网上写的博客，发现真心好，帮我理解什么叫委托参考文章我看了这篇文章2遍，反复看，才会越来越理解，写一下自己的理解，方便以后查阅，借鉴文章中的热水器的例子委托(delegate)：委托可以被视为一个更高级的指针，它不仅仅能把地址指向另一个函数，而且还能传递参数，返回值等多个信息。 目录{:toc}Example1234567891011121314151617181920212223public void EnglishGreeting(string name) &#123; Console.WriteLine(&quot;Morning, &quot; + name);&#125;public void ChineseGreeting(string name)&#123; Console.WriteLine(&quot;早上好, &quot; + name);&#125;public enum Language&#123; English, Chinese&#125;public void GreetPeople(string name, Language lang)&#123; //做某些额外的事情，比如初始化之类，此处略 swith(lang)&#123; case Language.English: EnglishGreeting(name); break; case Language.Chinese: ChineseGreeting(name); break; &#125;&#125; &emsp;这个样子如果我还添加其他国家的代码，我还要去修改 GreetPeople这个方法，我想要的是不管添加多少个国家，我的总业务代码是不会变的，也就是GreetPeople这个方法不会变,那么委托就可以帮我们办到。123456789101112131415161718192021222324252627282930313233namespace Delegate &#123; //定义委托，它定义了可以代表的方法的类型 public delegate void GreetingDelegate(string name); class Program &#123; private static void EnglishGreeting(string name) &#123; Console.WriteLine(&quot;Morning, &quot; + name); &#125; private static void ChineseGreeting(string name) &#123; Console.WriteLine(&quot;早上好, &quot; + name); &#125; //注意此方法，它接受一个GreetingDelegate类型的方法作为参数 private static void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123; MakeGreeting(name); &#125; static void Main(string[] args) &#123; GreetingDelegate delegate1; delegate1 = EnglishGreeting; // 先给委托类型的变量赋值 delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法 // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法 GreetPeople(&quot;Jimmy Zhang&quot;, delegate1); Console.ReadKey(); &#125; &#125; &#125;输出如下：Morning, Jimmy Zhang早上好, 张子阳 &emsp;只需要在主函数中绑定事件，GreetPeople代码中添加引用即可，注意这时候的public delegate void GreetingDelegate(string name);是在类的外部，客户端可以随意修改它，接下来就是事件的工作了，封装他。。。,想具体了解，请看参考文档 委托、事件与Observer设计模式：&emsp;假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。 &emsp;现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。12345678910111213141516171819202122232425262728class Heater &#123; private int temperature; public void BoilWater() &#123; for (int i = 0; i &lt;= 100; i++) &#123; temperature = i; if (this.temperature &gt; 95) &#123; this.MakeAlert(this.temperature); this.ShowMsg(this.temperature); &#125; &#125; Console.WriteLine(&quot;加热&quot;); &#125; public void MakeAlert(int param) &#123; Console.WriteLine(&quot;报警,水已经&#123;0&#125;度了&quot;,param); &#125; public void ShowMsg(int param) &#123; Console.WriteLine(&quot;显示水温,当前温度：&#123;0&#125;度&quot;,param); &#125; &#125; 1234567static void Main(string[] args) &#123; Heater调用 Heater ht = new Heater(); ht.BoilWater(); Console.ReadKey(); &#125; &emsp;这是最普通的实现办法，让热水器去通知通知温度计和报警器。&emsp;这时候事件就来啦，事件就是有订阅者和通知者，这里订阅者就相当于温度计和警报器，他们关注了热水器的温度，当热水器的温度有变化时，通知订阅者变化了，自动的去调用。事件就是把委托封装了一层让其变为私有的。&emsp;这时候应该让温度计和报警器单独成一个类，作为一个独立的个体。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt; /// step2:观察者模式 /// Subject(隶属，受限制于)被监视的对象，包含其他对象所感兴趣的内容，比如 temperature ///Oberver:监视者，监视Subject的行为，当Subject中发生某件事时告诉Observer，并采取相应的行动 ///思路： Observer应告诉Subject我对你感兴趣，进行关注，也就是注册；Subject知道后保留对Observer的引用；通过引用自动调用Observer的方法; /// &lt;/summary&gt; /// 热水器 class Heater1 &#123; private int temperature; public delegate void BoilHandler(int param); //声明委托 public event BoilHandler BoilEvent; //声明事件 public void BoilWater() &#123; for (int i = 0; i &lt;= 100; i++) &#123; temperature = i; if (this.temperature &gt; 95) &#123; //this.MakeAlert(this.temperature); //this.ShowMsg(this.temperature); if (BoilEvent != null) BoilEvent(temperature); &#125; &#125; Console.WriteLine(&quot;加热&quot;); &#125; &#125; /// &lt;summary&gt; /// 报警器 /// &lt;/summary&gt; class Alarm &#123; public void MakeAlert(int param) &#123; Console.WriteLine(&quot;报警&quot;); Console.WriteLine(&quot;报警,水已经&#123;0&#125;度了&quot;, param); &#125; &#125; /// &lt;summary&gt; /// 显示器 /// &lt;/summary&gt; class Display &#123; public static void ShowMsg(int param) &#123; Console.WriteLine(&quot;显示水温,当前温度：&#123;0&#125;度&quot;, param); &#125; &#125; 1234567891011static void Main(string[] args) &#123; //Heater1调用 Heater1 heater1 = new Heater1(); heater1.BoilEvent += (new Alarm()).MakeAlert; //匿名注册方法 heater1.BoilEvent += Display.ShowMsg; //注册静态对象方法 heater1.BoilWater(); //会自动调用注册过的方法 Console.ReadKey(); &#125; 以上是最基本的事件和委托的关系。 .Net Framework中的委托与事件 .Net Framework的编码规范：1.委托类型的名称：都应该以EventHandler结束。2.委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。3.事件的命名为：委托去掉 EventHandler之后剩余的部分。4.继承自EventArgs的类型应该以EventArgs结尾。 再做一下说明(copy)： &emsp;委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// &lt;summary&gt; /// 符合 .Net Framework /// &lt;/summary&gt; class Heater2 &#123; private int temperature; public string type = &quot;RealFire 001&quot;; // 添加型号作为演示 public string area = &quot;China Xian&quot;; // 添加产地作为演示 //public delegate void BoilHandler(int param); //声明委托 //public event BoilHandler BoilEvent; //声明事件 //声明委托 public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e); //声明事件 public event BoiledEventHandler Boiled; // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息 public class BoiledEventArgs : EventArgs &#123; public readonly int temperature; public BoiledEventArgs(int temperature) &#123; this.temperature = temperature; &#125; &#125; //在基类（父类）中用virtual修饰符声明一个虚方法，然后在在派生类（子类）中用//override修饰符覆盖基类虚方法。表明是对基类的虚方法重载。 // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视 protected virtual void OnBoiled(BoiledEventArgs e) &#123; if (Boiled != null) &#123; Boiled(this,e); //调用所有注册对象的方法 &#125; &#125; public void BoilWater() &#123; for (int i = 0; i &lt;= 100; i++) &#123; temperature = i; if (this.temperature &gt; 95) &#123; //this.MakeAlert(this.temperature); //this.ShowMsg(this.temperature); //if (BoilEvent != null) // BoilEvent(temperature); //建立BoiledEventArgs 对象。 BoiledEventArgs e = new BoiledEventArgs(temperature); OnBoiled(e); // 调用 OnBolied方法 &#125; &#125; Console.WriteLine(&quot;加热&quot;); &#125; &#125; /// &lt;summary&gt; /// 报警器 /// &lt;/summary&gt; class Alarm2 &#123; public void MakeAlert(Object sender,Heater2.BoiledEventArgs e) &#123; Heater2 heater = (Heater2)sender; Console.WriteLine(&quot;Alarm：&#123;0&#125; - &#123;1&#125;: &quot;, heater.area, heater.type); Console.WriteLine(&quot;报警,水已经&#123;0&#125;度了&quot;, e.temperature); &#125; &#125; /// &lt;summary&gt; /// 显示器 /// &lt;/summary&gt; class Display2 &#123; public static void ShowMsg(int param) &#123; Console.WriteLine(&quot;显示水温,当前温度：&#123;0&#125;度&quot;, param); &#125; &#125; 1234567891011static void Main() &#123; Heater2 heater = new Heater2(); Alarm alarm = new Alarm(); heater.Boiled += alarm.MakeAlert; //注册方法 heater.Boiled += (new Alarm()).MakeAlert; //给匿名对象注册方法 heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert); //也可以这么注册 heater.Boiled += Display.ShowMsg; //注册静态方法 heater.BoilWater(); //烧水，会自动调用注册过对象的方法 &#125; 总的来说（我的理解）委托相当于是一个类型，同于string ，不同的是，他的变量值是另一个方法的名称，而且定义这个委托时，注意与委托给他的方法参数一致。。。事件就是委托的封装，让他private，但是持有的参数是和委托一致的。]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub上利用Jekyll框架搭建个人博客]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17-In%20github%20build%20jekyll%2F</url>
    <content type="text"><![CDATA[目录{:toc}导语：自己搭建博客在个github上部署了好久一直是404，后来某一天才发现是自己理解错了，总结下来。GitHub Pages GitHub Pages 是由官方托管和发布的，你可以使用 GitHub 提供的页面自动生成器。也可以做个人博客，是个轻量级的博客系统，没有麻烦的配置。使用标记语言如Markdown，不需自己搭建服务器，还可以绑定自己的域名。我这里没有绑定域名，所以不作介绍。 GitHub 域名的创建 在Github上创建仓库，但是仓库名字一定要是 xxx.github.io 格式一定要是这个样子，xxx是github注册的用户名，不能是其他，这个是在master分支上规定的，如果想用其他域名，就新创建一个gh-pages,再来自定义xxx的名字。 把创建的仓库克隆到本地 在本地git配置好以及和github远程连接建立好后，进行如下步骤。1.把刚刚创建的仓库克隆到本地 git clone xxx 2.把Vno-jekyll clone到仓库下，注意clone后vno-jekyll文件夹里面的内容提到仓库根目录下，删除vno-jekyll文件。我之前就是把vno-jekyll直接传上去了，没有比我更蠢的了，就报一直找不到index.html.3.安装 [ruby] 百度 安装ruby后才能执行gem操作4.cmd 下 执行gem install jekyll （vpn快点）测试 gem source 是否安装成功5.然后 git切换到仓库根目录下执行 bundle install如果出现bundle: command not found先安装bundle: gem install bundle6.一切就绪后 开启jekyll环境 ：bundle exec jekyll serve 在浏览器上访问 http://127.0.0.1:4000/见到喵神就对了7.把代码都push上去 (以下命令只针对我的电脑) 123git add .&lt;br&gt;git cmmmit -m &quot;blog&quot;&lt;br&gt;git push origin master&lt;br&gt; 8.在浏览器上访问 xxx.github.io就可以看到了。 具体搭建后的具体操作，我也是小白，由于时间关系，后续更新。图片之后再插。参考文章]]></content>
      <categories>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
</search>
